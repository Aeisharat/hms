<?php

	define('CAKE_PATH', '../../../lib/Cake/');
	define('APP_PATH', '../../../app/');
	
	require_once(CAKE_PATH . 'Core/App.php');
	require_once(CAKE_PATH . 'Core/Object.php');
	require_once(CAKE_PATH . 'Event/CakeEventListener.php');
	require_once(CAKE_PATH . 'Model/Model.php');
	require_once(APP_PATH . 'Model/AppModel.php');
	require_once(APP_PATH . 'Model/Status.php');
	require_once(APP_PATH . 'Model/Account.php');
	require_once(APP_PATH . 'Model/Pin.php');
	require_once(APP_PATH . 'Lib/CsvReader/CsvReader.php');

	/*
		This script is used to generate realistic(ish) data for use when manually testing HMS.
		It is mainly powered by data generated by http://www.fakenamegenerator.com/
		Data provided by http://www.fakenamegenerator.com/ is used under the
		Creative Commons Attribution-Share Alike 3.0 United States license.
	*/

	class DataGenerator
	{
		private $stockData = array(); //!< The stock data used to populate other fields.

		private $members = array(); //!< Array of members.
		private $accounts = array(); //!< Array of accounts.
		private $pins = array(); //!< Array of pins.
		private $rfidTags = array(); //!< Array of rfid tags.

		//! Constructor
		function __construct()
		{
			$this->_parseCsv('./FakeNameGeneratorDataShort.csv');
		}

		//! Given a relative path from this file, get an absolute path.
		/*!
			@param string $path The relative path to convert.
			@retval string The absolute path.
		*/
		private function _makeAbsolutePath($path)
		{
			return dirname(__FILE__) . '/' . basename($path);
		}

		//! Parse a CSV file, adding the data to the stockData array.
		/*!
			@param $filepath string Path to the .csv file to try and parse.
		*/
		private function _parseCsv($filepath)
		{
			$csvReader = new CsvReader();

			if($csvReader->readFile($this->_makeAbsolutePath($filepath)))
			{
				$numLines = $csvReader->getNumLines();

				// If the .csv is sane, the first line is the headers
				$headers = $csvReader->getLine(0);

				if($headers != null)
				{
					for($i = 1; $i < $numLines; $i++)
					{
						// For every line, convert the indexed array to an associated array
						// using the headers as keys

						$line = $csvReader->getLine($i);
						if( $line != null &&
							count($line) == count($headers) )
						{
							$assocLine = array();
							for($j = 0; $j < count($line); $j++)
							{
								$assocLine[$headers[$j]] = $line[$j];
							}
							array_push($this->stockData, $assocLine);
						}
					}
				}
			}
		}

		//! Generate a new member record
		/*!
			@param int $membershipStage The stage of membership this member should be at, see Status model for details.
		*/
		public function generateMember($membershipStage)
		{
			$memberId = count($this->members) + 1;

			$creditLimit = 0;
			$balance = 0;
			$joinDate = '';
			$accountId = null;

			if((int)$membershipStage >= Status::CURRENT_MEMBER)
			{
				$creditLimit = 5000;
				$balance = rand(-$creditLimit, 0);

				// Make it so they joined some time in the last year
				$now = time();
				$lastYear = strtotime('last year');
				$joinTimestamp = rand($lastYear, $now);
				$joinDate = date('Y-m-d', $joinTimestamp);

				$accountId = $this->_generateAccount();
				$this->_generatePin($memberId, $joinTimestamp);

				// Has this member set up access yet?
				// Pick a date within a week of the join date
				// and if that date has passed then member has set up a card
				$weekAfterJoin = strtotime('+1 week', $joinTimestamp);
				$registerTime = rand($joinTimestamp, $weekAfterJoin);
				if($registerTime <= $now)
				{
					$this->_registerCard($memberId, $registerTime);
				}
			}

			$stockData = $this->_getStockData();

			$firstname = $stockData['GivenName'];
			$surname = $stockData['Surname'];
			$email = $stockData['EmailAddress'];
			$handle = $stockData['Username'];
			$username = $handle;

			$address = array(
				$stockData['StreetAddress'],
				'',
				$stockData['City'],
				$stockData['ZipCode']
			);

			$contactNumber = $stockData['TelephoneNumber'];

			$record = array(
				'member_id' => $memberId,
				'firstname' => $firstname,
				'surname' => $surname,
				'email' => $email,
				'join_date' => $joinDate,
				'handle' => $handle,
				'unlock_text' => 'Welcome ' . $firstname,
				'balance' => $balance,
				'credit_limit' => $creditLimit,
				'member_status' => $membershipStage,
				'username' => $username,
				'account_id' => $accountId,
				'address_1' => $address[0],
				'address_2' => $address[1],
				'address_city' => $address[2],
				'address_postcode' => $address[3],
				'contact_number' => $contactNumber
			);

			var_dump($record);

			array_push($this->members, $record);
		}

		//! Register an rfid card using the members pin.
		/*!
			@param int $memberId The id of the member to register the card to.
			@param int $registerTime The time the card was registered.
		*/
		private function _registerCard($memberId, $registerTime)
		{
			// Registering a card effects the PIN
			for($i = 0; $i < count($this->pins); $i++)
			{
				if($this->pin[$i]['member_id'] == $memberId)
				{
					$this->pin[$i]['state'] = 40;
					break;
				}
			}

			// The RFID serial seems to be between 9 and 10 numbers starting with 1
			$serialLenRemaining = 9;
			$serial = '1';
			if(rand() % 2 == 0)
			{
				$serialLenRemaining = 8;
			}
			for($i = 0; $i < $serialLenRemaining; $i++)
			{
				$serial .= rand(0, 9);
			}

			// Make it so the card was used within the last month
			// (all members turn up at-least once a month right? ;) )
			$aMonthAgo = time('-1 month');

			$lastUsedMin = $aMonthAgo;
			// Can't have used it before it was registered...
			if($aMonthAgo < $registerTime)
			{
				$lastUsedMin = $registerTime;
			}

			//  Pick a time between then and now
			$lastUsed = rand($lastUsedMin, time());


			// Now add an rfid record
			$record = array(
				'member_id' => $memberId,
				'rfid_serial' => $serial,
				'state' => 10,
				'last_used' => $lastUsed,
			);

			array_push($this->rfidTags, $record);
		}

		//! Generate a new account record.
		/*!
			@retval int The id of the record.
		*/
		private function _generateAccount()
		{
			$accountId = count($this->accounts) + 1;

			$accountRef = $this->_generateUniqueEntry($this->accounts, 'payment_ref', function() { return Account::generatePaymentRef(); } );

			$record = array(
				'account_id' => $accountId,
				'payment_ref' => $accountRef,
			);

			array_push($this->accounts, $record);

			return $accountId;
		}

		//! Generate a new pin record
		/*!
			@param int $memberId The id of the member the pin belongs to.
			@param int $joinTimestamp The time the pin was generated.
		*/
		private function _generatePin($memberId, $joinTimestamp)
		{
			$pinId = count($this->pins) + 1;

			$pin = $this->_generateUniqueEntry($this->pins, 'pin', function () { return Pin::generatePin(); } );

			$record = array(
				'pin_id' => $pinId,
				'pin' => $pin,
				'unlock_text' => 'NOT USED',
				'date_added' => date("Y-m-d H:i:s", $joinTimestamp),
				'expiry' => null,
				'state' => 30,
				'member_id' => $memberId
			);

			array_push($this->pins, $record);
		}

		//! Given an array of array data, a key to the inner array, and a function to generate data, keep generating until the data is unique.
		/*!
			@param array $records Array of existing records.
			@param string $key Index in existing records to check.
			@param function $genFunc The function used to generate new data.
			@retval mixed A unique value returned from $genFunc.
		*/
		private function _generateUniqueEntry($records, $key, $genFunc)
		{
			$item = '';
			$isUnique = false;
			do
			{
				$item = $genFunc();
				$isUnique = true;

				foreach ($records as $record) 
				{
					if($record[$key] == $item)
					{
						$isUnique = false;
						break;
					}
				}

			} while( !$isUnique );

			return $item;
		}

		//! Pop a single element of the stock data and return it.
		/*!
			@retval array The data requested.
		*/
		private function _getStockData()
		{
			$index = rand(0, count($this->stockData) - 1);
			$data = $this->stockData[$index];
			array_splice($this->stockData, $index, 1);
			return $data;
		}
	}
?>